# 부하 테스트 보고서

## 🖼️ 배경

이커머스 시스템의 핵심 비즈니스 기능에 대해 고가용성(High Availability)을 확보하기 위해 부하 테스트를 수행한다.  
이번 테스트를 통해 병목 지점을 사전에 파악하여 성능 저하를 방지하고,   
테스트 결과를 기반으로 한 TPS(Transactions Per Second)를 기준으로 적정 서버 Pod 수와 필요한 리소스를 산정할 수 있다.  
또한, 실제 트래픽 상황을 재현하여 장애 발생 구간을 사전에 점검함으로써 시스템 안정성을 확보하고자 한다.

## 📌 대상 선정

부하 테스트의 대상은 시스템의 핵심 비즈니스 기능을 기준으로 선정하였다.  
이번 테스트에서는 주문/결제 시나리오와 선착순 쿠폰 발급 시나리오를 중심으로 진행한다.

### 🛒 주문/결제

주문/결제는 사용자 경험과 직접적으로 연결된 핵심 서비스 기능으로,     
실제 사용 흐름을 기반으로 시나리오를 구성하여 부하 테스트를 수행하였다.

테스트 시나리오는 다음과 같은 단계로 구성된다.

1. 인기상품 조회
2. 잔액 충전
3. 잔액 조회
4. 주문/결제 진행
5. 주문 완료 상태 확인

실제 사용자 전체가 상품을 조회한 후 주문까지 진행하지는 않기 때문에,   
현실적인 사용자 행동 양상을 반영하여 다음과 같은 가정을 두고 테스트를 구성하였다.

- 전체 사용자 중 20% 사용자만 잔액 충전
- 충전 사용자 중 10% 사용자만 주문/결제

이와 같은 조건을 통해 정상적인 비즈니스 흐름을 유지하면서도 실제 트래픽 양상에 가까운 테스트를 설계하였다.

### 🎟️ 선착순 쿠폰 발급

선착순 쿠폰 발급 기능은 시스템 내에서 가장 높은 단일 시점 트래픽이 집중되는 기능이다.  
이 기능의 안정성을 검증하기 위해, 고부하 상황을 집중적으로 발생시키는 Peak Test 방식으로 시나리오를 구성하였다.

특정 시점에 다수의 사용자가 동시에 쿠폰을 요청하는 상황을 재현하여,  
트래픽 집중 시의 응답 시간, 처리율, 에러 발생 여부 등을 중점적으로 검증한다.  
이를 통해 트래픽 폭주 상황에서도 시스템이 안정적으로 동작하는지 확인하고자 한다.

## 🛠️ 테스트 환경 구축

테스트 환경은 로컬 PC의 도커 컨테이너를 활용하여 구성하였다.

### Spring 테스트 환경

다음은 스플링 어플리케이션 `docker-compose.yml` 일부이다.

```yaml
version: '3'
services:
  api:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=dev
      - TZ="Asia/Seoul"
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 4G
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml:ro
```

Spring 애플리케이션의 리소스를 제한하기 위해 CPU는 2 vCPU, 메모리는 4 GB로 설정하였다.  
추가로, Spring Actuator를 통해 메트릭을 수집하고, Prometheus 및 Grafana와 연동하여 모니터링 대시보드를 구성하였다.

#### `build.gradle.kts`의 의존성 추가

```groovy
dependencies {
    // ... 생략 ...

    // Actuator
    implementation("org.springframework.boot:spring-boot-starter-actuator")
    implementation("io.micrometer:micrometer-registry-prometheus")
}
```

#### `prometheus.yml` 추가

```yaml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'spring-app'
    metrics_path: '/actuator/prometheus'
    static_configs:
      - targets: [ 'api:8080' ]
```

#### `application.yml`의 actuator 설정 추가

```yaml
management:
  endpoint:
    health:
      show-details: always
  endpoints:
    web:
      exposure:
        include: "*"
  metrics:
    enable:
      all: true
```

---

### K6 테스트 환경

부하 테스트 도구로는 K6를 사용하였으며, InfluxDB 및 Grafana와 연동하여 테스트 결과를 시각화하였다.  
다음은 InfluxDB와 Grafana를 위한 `docker-compose.yml` 일부이다.

```yaml
services:
  influxdb:
    image: influxdb:1.8
    networks:
      - k6
      - grafana
    ports:
      - "8086:8086"
    environment:
      - INFLUXDB_DB=k6

  grafana:
    image: grafana/grafana:9.3.8
    networks:
      - grafana
    ports:
      - "3000:3000"
    environment:
      - GF_AUTH_ANONYMOUS_ORG_ROLE=Admin
      - GF_AUTH_ANONYMOUS_ENABLED=true
      - GF_AUTH_BASIC_ENABLED=false
    volumes:
      - ./grafana:/etc/grafana/provisioning/
```

이와 같이 로컬 Docker 기반의 통합 테스트 및 모니터링 환경을 구축하였다.

![img_8.png](img_8.png)

## 🎯 테스트 설계 및 목적

### 🛒 주문/결제

#### 테스트 시나리오

주문/결제 기능은 단기간 폭증보다는 일정 수준의 트래픽이 지속적으로 유지되는 특성이 있으므로,   
Load Test 방식으로 최대 300 Virtual Users(VU)까지 점진적으로 증가시키는 테스트를 설계하였다.

1. 10초 동안 100 VU 까지 증가
2. 10초 동안 200 VU 까지 증가
3. 10초 동안 300 VU 까지 증가
4. 30초 동안 300 VU 유지
5. 10초 동안 100 VU 까지 감소
6. 10초 동안 50 VU 까지 감소
7. 10초 동안 0 VU 까지 감소

#### 목표 TPS

| 기능      | 사용자 기준 | 처리 빈도    | 목표 TPS  |
|---------|--------|----------|---------|
| 인기상품 조회 | 100명   | 1초에 1건   | 100 TPS |
| 잔액 충전   | 100명   | 10초에 1건  | 10 TPS  |
| 주문/결제   | 100명   | 100초에 1건 | 1 TPS   |

#### 테스트 데이터

##### 랭킹 데이터 생성

인기상품 조회 시 필요한 랭킹 데이터를 Redis에 사전 적재하였다.

```redis
ZINCRBY rank:sell:{date:yyyMMdd} {score : 판매량} {productId : 상품 ID}
```

##### 상품 및 재고 데이터 생성

주문/결제 시에 필요한 상품 및 재고 데이터를 각각 10,000건 생성하였다.

```sql
-- 상품 및 재고 데이터 생성을 위한 프로시저
DELIMITER
//
CREATE PROCEDURE generate_product_stock_data()
BEGIN
  DECLARE
i INT DEFAULT 1;
  DECLARE
product_id INT;

  WHILE
i <= 10000 DO
    -- 상품 추가
    INSERT INTO product (name, price, sell_status)
    VALUES (CONCAT('상품명', i), 1000, 'SELLING');

    -- 방금 추가된 상품의 ID 가져오기
    SET
product_id = LAST_INSERT_ID();

    -- 재고 추가
INSERT INTO stock (product_id, quantity)
VALUES (product_id, 1000);

SET
i = i + 1;
END WHILE;
END
//
DELIMITER ;
```

##### 잔액 데이터 생성

잔액 충전 및 조회를 위해 사용자 데이터를 약 10,000 개 생성하였다.

```sql
DELIMITER
//
CREATE PROCEDURE generate_balance_data()
BEGIN
  DECLARE
i INT DEFAULT 1;

  WHILE
i <= 10000 DO
    INSERT INTO balance (user_id, amount, version)
    VALUES (i, 1000000, 0);

    SET
i = i + 1;
END WHILE;
END
//
DELIMITER ;
```

#### 테스트 스크립트

##### SLA 설정 

- **HTTP 요청의 P99 응답 시간**은 **1초 이하**를 목표로 한다.
- **HTTP 요청 실패율**은 **1% 미만**으로 제한한다.

##### 시나리오 구성

1. 인기상품 조회 : 인기상품 목록을 조회한 후, **응답받은 상품 중 하나를 랜덤으로 선택**한다.
2. 포인트 충전 :  **20% 확률로 포인트를 충전**하고, 이어서 **잔액을 조회**한다.
3. 주문/결제 : **10% 확률로 선택된 상품을 주문**하여 주문 요청을 수행한다.
4. 주문 상태 확인 : 주문/결제는 이벤트 기반으로 처리되므로, **일정 시간 지연 후 상태 조회 API를 호출**하여 주문 상태가 `"COMPLETED"`로 변경되었는지 확인한다.

```javascript
import http from 'k6/http';
import {sleep, check, group} from "k6";
import {randomIntBetween} from 'https://jslib.k6.io/k6-utils/1.2.0/index.js';

export const options = {
    stages: [
        {duration: '10s', target: 100},
        {duration: '10s', target: 200},
        {duration: '10s', target: 300},
        {duration: '30s', target: 300},
        {duration: '10s', target: 100},
        {duration: '10s', target: 50},
        {duration: '10s', target: 0}
    ],
    thresholds: {
        http_req_duration: ['p(99)<1000'],
        http_req_failed: ['rate<0.01']
    }
};

const BASE_URL = 'http://127.0.0.1:8080/api/v1';
const ORDER_CHECK_INTERVAL = 2; // 주문 상태 확인 간격(초)

export default function main() {
    // 1~1000 사이의 랜덤 사용자 ID 생성
    const userId = randomIntBetween(1, 1000);

    // 생성된 주문 ID를 저장할 변수
    let orderId = null;
    let shouldOrder = false;
    let shouldChargeBalance = false;
    let selectedProduct = null;

    group('주문/결제 시나리오', () => {
        // 1. 인기 상품 조회
        const popularProductsResponse = http.get(`${BASE_URL}/api/v0/products/ranks`, {
            tags: {name: '인기상품조회'}
        });

        check(popularProductsResponse, {
            '인기상품 조회 성공': (r) => r.status === 200,
            '인기상품 데이터 확인': (r) => {
                const body = JSON.parse(r.body);
                return body.data && Array.isArray(body.data.products) && body.data.products.length > 0;
            }
        });

        if (popularProductsResponse.status === 200) {
            const body = JSON.parse(popularProductsResponse.body);
            if (body.data && Array.isArray(body.data.products) && body.data.products.length > 0) {
                // 인기 상품 목록에서 랜덤하게 하나 선택
                const products = body.data.products;
                selectedProduct = products[Math.floor(Math.random() * products.length)];

                shouldChargeBalance = Math.random() < 0.2;
            }
        }

        // 2. 포인트 충전 및 조회 진행
        if (shouldChargeBalance) {
            const payload = JSON.stringify({
                amount: 10000
            });

            const params = {
                headers: {
                    'Content-Type': 'application/json',
                },
                tags: {name: '포인트충전'}
            };

            const chargeResponse = http.post(`${BASE_URL}/users/${userId}/balance/charge`, payload, params);

            check(chargeResponse, {
                '포인트 충전 성공': (r) => r.status === 200,
                '포인트 충전 확인': (r) => {
                    if (r.status === 200) {
                        const body = JSON.parse(r.body);
                        return body.code === 200 && body.message === 'OK';
                    }
                    return false;
                }
            });

            // 포인트 조회
            const balanceResponse = http.get(`${BASE_URL}/users/${userId}/balance`, {
                tags: {name: '포인트조회'}
            });

            check(balanceResponse, {
                '포인트 조회 성공': (r) => r.status === 200,
                '포인트 잔액 확인': (r) => {
                    if (r.status === 200) {
                        const body = JSON.parse(r.body);
                        return body.data && body.data.amount !== undefined;
                    }
                    return false;
                }
            });

            // 10% 확률로 주문 진행
            shouldOrder = Math.random() < 0.1;
        }

        // 3. 주문 결제 진행
        if (shouldOrder && selectedProduct) {
            const orderPayload = JSON.stringify({
                userId: userId,
                products: [
                    {
                        id: selectedProduct.id,
                        quantity: 1
                    }
                ]
            });

            const orderParams = {
                headers: {
                    'Content-Type': 'application/json',
                },
                tags: {name: '상품주문'}
            };

            const orderResponse = http.post(`${BASE_URL}/orders`, orderPayload, orderParams);

            check(orderResponse, {
                '주문 생성 성공': (r) => r.status === 200,
                '주문 확인': (r) => {
                    if (r.status === 200) {
                        const body = JSON.parse(r.body);
                        if (body.data && body.data.orderId) {
                            orderId = body.data.orderId;
                            return true;
                        }
                    }
                    return false;
                }
            });

            // 4. 주문 상태 확인
            if (orderId) {
                sleep(ORDER_CHECK_INTERVAL);

                const orderStatusResponse = http.get(`${BASE_URL}/orders/${orderId}`, {
                    tags: {name: '주문상태확인'}
                });

                check(orderStatusResponse, {
                    '주문 상태 조회 성공': (r) => r.status === 200,
                    '주문 상태 확인': (r) => {
                        if (r.status === 200) {
                            const body = JSON.parse(r.body);
                            if (body.data && body.data.status === 'COMPLETED') {
                                return true;
                            }
                        }
                        return false;
                    }
                });
            }
        } else {
            sleep(1);
        }
    });

    sleep(1);
}
```

### 🎟️ 선착순 쿠폰 발급

#### 테스트 시나리오

선착순 쿠폰 발급은 이벤트성 트래픽이 단시간에 많이 집중되는 비지니스로,  
급격한 부하가 집중되는 Peak Test 방식으로 최대 1000 VU까지 테스트를 진행한다.

1. 10초 동안 10 VU 까지 증가
2. 10초 동안 10 VU 유지
3. 10초 동안 700 VU 까지 증가
4. 10초 동안 10 VU 까지 감소
5. 10초 동안 10 VU 유지
6. 10초 동안 1000 VU 까지 증가
7. 10초 동안 10 VU 까지 감소
8. 10초 동안 0 VU 까지 감소

#### 목표 TPS

| 기능    | 사용자 기준 | 처리 빈도       | 목표 TPS  |
|-------|--------|-------------|---------|
| 쿠폰 발급 | 100명   | 0.5초당 1건 처리 | 200 TPS |

#### 테스트 데이터

테스트를 위해 쿠폰 데이터를 생성하였다.

```sql
CREATE PROCEDURE generate_coupon_data()
BEGIN
  DECLARE
i INT DEFAULT 1;

INSERT INTO coupon (name, quantity, discount_rate, expired_at, status)
VALUES (CONCAT('쿠폰명', i), 10000, 0.3, DATE_ADD(CURRENT_DATE(), INTERVAL 7 DAY), 'PUBLISHABLE');

END
//
```

쿠폰 발급을 위한 쿠폰 발급 여부를 확인하는 값을 Redis에 적재 하였다.

```redis
SET coupon_avaliable:{couponId} true
```

#### 테스트 스크립트

##### SLA 설정

- **HTTP 요청의 P99 응답 시간**은 **1초 이하**를 목표로 한다.
- **HTTP 요청 실패율**은 **5% 미만**으로 제한한다.

쿠폰 ID는 고정하였으며, 사용자 ID는 최대한 중복 ID가 생기지 않게 끔 VU ID와 시나리오 반복 횟수를 조합하여 생성하였다.

```javascript
import http from 'k6/http';
import {sleep, check, group} from "k6";
import {randomIntBetween} from 'https://jslib.k6.io/k6-utils/1.2.0/index.js';
import exec from 'k6/execution';

export const options = {
    stages: [
        {duration: '10s', target: 10},
        {duration: '10s', target: 10},
        {duration: '10s', target: 700},
        {duration: '10s', target: 10},
        {duration: '10s', target: 10},
        {duration: '10s', target: 1000},
        {duration: '10s', target: 10},
        {duration: '10s', target: 0}
    ],
    thresholds: {
        http_req_duration: ['p(99)<1000'],
        http_req_failed: ['rate<0.05']
    },
};

const BASE_URL = 'http://127.0.0.1:8080/api/v0';

export default function main() {
    const userId = (exec.vu.idInTest * 1_000_000) + exec.vu.iterationInScenario;
    const couponId = 1;

    // 쿠폰 발급 요청
    group('쿠폰발급', () => {
        const payload = JSON.stringify({
            couponId: couponId
        });

        const params = {
            headers: {
                'Content-Type': 'application/json',
            },
            tags: {name: '쿠폰발급'}
        };

        const response = http.post(
            `${BASE_URL}/users/${userId}/coupons/publish`,
            payload,
            params
        );

        check(response, {
            '쿠폰 발급 성공': (r) => r.status === 200,
        });
    });

    sleep(randomIntBetween(1, 3));
}
```
