# 캐시(Cache)

## ⚡️ 캐시(Cache)란?

캐시는 **자주 사용하는 데이터나 연산 결과를 임시로 저장하는 저장소**다.  
느린 저장소(예: RDB, API 등)에 반복적으로 접근하는 대신, 더 빠른 저장소(예: 메모리)에 데이터를 저장해두고  
다음 요청 때는 이 저장된 데이터를 바로 반환하는 방식으로 동작한다.

## ❓ 그럼 왜 캐시를 사용할까?

RDB는 스케일 업이나 스케일 아웃이 가능하지만, 비용이 많이 들고 확장에도 한계가 있다.  
또한, 외부 API는 내가 직접 제어할 수 없는 영역이기 때문에 응답 속도를 개선하기 어렵다.

이런 제약 속에서, 리소스 사용 비용을 줄이고 시스템 성능을 높이기 위한 대안으로 캐시가 사용된다.

## ⚠️ 캐시의 문제

캐시는 리소스 사용을 줄이고 시스템 성능을 높이는 데 효과적이지만, **데이터 정합성** 문제를 일으킬 수 있다.  
원본 데이터가 변경됐을 때 캐시에 저장된 데이터가 갱신되지 않으면 캐시와 원본 데이터 사이에 불일치가 발생한다.  
데이터의 성격에 따라 정합성을 꼭 지켜야 하는 경우도 있고, 그렇지 않은 경우도 있다.

> 예를 들어, 인기상품 조회처럼 데이터 정합성이 크게 중요하지 않은 경우도 있지만,  
> 재고 조회처럼 실시간 데이터 정합성이 중요한 상황에서는 캐시 사용에 신경 써야 한다.

## 🧩 캐시 전략

위의 예시처럼 캐시를 사용할 때는 데이터 정합성을 고려한 **캐시 전략**을 세워야 한다.  
캐시 전략은 크게 **읽기 전략**과 **쓰기 전략**으로 나눌 수 있다.

### 📌 읽기 전략

캐시를 조회할 때 어떤 방식으로 데이터를 가져올지 결정하는 전략이다.

#### Look Aside

캐시를 먼저 조회하고, 캐시에 없으면 RDB에서 데이터를 가져와 캐시에 저장하는 방식이다.  
이 방식은 캐시 미스가 발생했을 때 RDB에서 데이터를 조회하므로 장애 상황에도 유연하게 대응할 수 있다.

> 예를 들어, 상품 상세 데이터에 적용하기 적합하다.  
> 상품 상세 데이터는 양이 많아 캐시에 미리 모두 적재하기 어렵고, 자주 조회되지 않는 데이터까지 캐싱하면 비효율적이기 때문이다.

![img_1](https://github.com/user-attachments/assets/566a241b-cd6f-4ca0-bfb9-fd94a49f91b8)

#### Read Through

캐시만 조회하는 전략으로, 캐시에 데이터가 없으면 RDB를 조회하지 않아 서비스 장애로 이어질 수 있다.  
이 방식은 자주 조회되는 데이터에 적합하다.

> 예를 들어, 인기 상품 조회에 적용할 수 있다.  
> 인기 상품은 자주 조회되기 때문에 캐시에 미리 적재해두면 효율적이다.  
> 하지만 캐시에 데이터가 없으면 장애로 이어질 수 있으므로, 어플리케이션 실행 시 데이터를 미리 적재하는 **캐시 웜업**이 필요하다.

![img](https://github.com/user-attachments/assets/f5b2b816-ad9c-4a36-9fee-694269e57823)

### 📌 쓰기 전략

캐시에 데이터를 저장할 때 어떤 방식으로 처리할지 결정하는 전략이다.

#### Write Around

RDB에만 데이터를 저장하고, 캐시 미스가 발생할 때만 캐시에 데이터를 갱신하는 방식이다.  
이 방식은 캐시 미스 시에만 캐시가 갱신되기 때문에 데이터 정합성이 완벽하게 보장되지 않는다.  

![img_3](https://github.com/user-attachments/assets/05674a22-19a3-43ad-a225-cc733b68789c)

#### Write Back (Write Behind)

갱신된 데이터를 먼저 캐시에 저장하고, 일정 주기로 배치 작업을 통해 RDB에 반영하는 방식이다.  
RDB에 대한 쓰기 부하를 줄일 수 있지만, 캐시 장애가 발생하면 데이터 유실 위험이 있고 캐시에 대한 의존도가 높다. 

![img_5](https://github.com/user-attachments/assets/3142a66d-afa2-4cd2-b4fb-3c564634679a)

#### Write Through

RDB와 캐시에 동시에 데이터를 저장하는 방식으로, 데이터 정합성을 보장할 수 있다.  
하지만 자주 사용되지 않는 데이터까지 캐시에 저장하면 불필요한 리소스가 소모될 수 있다.

![img_2](https://github.com/user-attachments/assets/92291d8f-13bd-4a80-927f-809033bbe520)

### 📌 캐시 전략 요약

| 전략                | 장점                                | 단점                                    | 주요 사용 예시     |
|-------------------|-----------------------------------|---------------------------------------|--------------|
| Look Aside        | - 장애에 유연하게 대응<br>- 불필요한 데이터 캐싱 방지 | - 자주 조회되는 데이터는 매번 RDB 접근 필요           | 상품 상세 데이터    |
| Read Through      | - 자주 조회되는 데이터에 효율적<br>- 코드가 단순해짐  | - 캐시 미스 시 장애 위험<br>- 캐시 웜업 필요         | 인기 상품 조회     |
| Write Around      | - 불필요한 데이터 캐싱 최소화                 | - 데이터 정합성 보장 어려움<br>- 캐시 미스 시 느린 응답   | 변경이 적은 데이터   |
| Write Back/Behind | - RDB 쓰기 부하 감소<br>- 빠른 쓰기 처리      | - 캐시 장애 시 데이터 유실 위험<br>- 캐시에 의존적      | 로그, 임시 데이터   |
| Write Through     | - 데이터 정합성 보장                      | - 불필요한 리소스 소모<br>- 자주 사용되지 않는 데이터도 캐싱 | 정합성이 중요한 데이터 |


## 🏃 캐시 웜업 (Cache Warm-up)

캐시 웜업은 캐시를 미리 적재해두는 작업을 의미한다.    
트래픽이 순간적으로 급증하는 패턴이 있을 때 캐시 미스가 발생하면 RDB에 부하가 걸릴 수 있고, 이는 **캐시 스탬피드** 현상으로 이어질 수 있다.

> 캐시 웜업을 하지 않으면 첫번째로 요청한 사용자만 늦은 응답을 받게 될 수 있다. 

### 📌 캐시 스탬피드

특정 키에 대한 캐시가 비어 있을 때, 캐시 미스로 인해 RDB에 읽기 부하와 캐시에 쓰기 부하가 동시에 급증하는 현상이다.  
이로 인해 처리량이 느려지고, 결국 서비스 장애로 이어질 수 있다.

캐시 스탬피드를 방지하기 위해서는 캐시를 미리 적재하는 **캐시 웜업**을 수행하거나,   
읽기 전략으로 Read Through 전략을 사용하는 것이 좋다.

## 🧹️ 캐시 무효화 

캐시 무효화는 기존에 저장된 캐시 데이터를 더 이상 사용하지 않도록 만드는 작업이다.  
더 이상 유효하지 않은 캐시 데이터를 삭제하거나 갱신하는 것을 의미한다.

> 앞서 언급했듯, 캐시의 가장 큰 문제는 데이터 정합성이다.  
> RDB의 데이터가 변경됐는데 캐시가 갱신되지 않으면, 사용자에게 잘못된 데이터를 제공할 수 있다.

### 📌 TTL (Time To Live)

캐시 데이터에 TTL(Time To Live)을 설정해 일정 시간이 지나면 자동으로 삭제되도록 할 수 있다.  
정합성이 크게 중요하지 않은 데이터에 적합하다.

### 📌 명시적 무효화 (Explicit Invalidation)

RDB 데이터가 변경됐을 때, 캐시를 명시적으로 삭제하거나 갱신하는 방법이다.

## 🗂️ 캐시 만료 정책

캐시의 크기를 관리하고 오래된 데이터를 자동으로 제거하기 위해  
LRU(Least Recently Used), LFU(Least Frequently Used), FIFO(First In First Out) 등 다양한 만료 정책이 사용된다.

## 🛠️ 캐시 종류

캐시는 크게 **로컬 캐시**와 **글로벌 캐시**로 나눌 수 있다.

### 📌 로컬 캐시

+ 각 인스턴스 내부 메모리에 저장되는 캐시로, 인스턴스가 종료되면 캐시도 함께 사라진다.
+ 인스턴스마다 독립된 캐시 공간을 사용하기 때문에 인스턴스 간 캐시 데이터 불일치가 발생할 수 있다.
+ 네트워크 트래픽이 없어서 빠른 응답 속도를 제공한다.

### 📌 글로벌 캐시

+ 여러 인스턴스가 공유하는 외부 캐시 저장소를 사용해, 인스턴스 간 캐시 일관성을 유지할 수 있다.
+ 네트워크를 통해 접근하기 때문에 로컬 캐시보다 상대적으로 느리다.



